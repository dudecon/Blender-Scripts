import bpy
from bpy import context as C
from pathlib import Path
from math import sqrt


JOGSPD = 1200
LSRSPD = 700
LSRPOW = 255

VERBOSE = False

ob = C.active_object
obname = ob.name
bpy.ops.object.duplicate()
bpy.ops.object.convert()
dta = C.active_object.data
bpy.ops.object.delete()
C.view_layer.objects.active = ob
ob.select_set(True)

savefile = f'//{obname}_bl.nc'

# store the edges as vert index pair tuples
edges = [(e.vertices[0], e.vertices[1]) for e in dta.edges]
# store the vertices as x,y tuples
verts = [(v.co[0], v.co[1]) for v in dta.vertices]

# build an array for finding any "corner" verticies.
# These are verticies which have anything other than 2 edges connected to them.

vertedgecounts = {}
def vertfound(i, d):
    if i in d: d[i] += 1
    else: d[i] = 1
vertconnections = {}
def vertedge(i, c, d):
    if i in d: d[i].append(c)
    else: d[i] = [c]
for e in edges:
    for id in (0,1): vertfound(e[id], vertedgecounts)
    for id in (0,1):
        connec = e[abs(id-1)]
        vertedge(e[id], connec, vertconnections)

cornerverts = set()
for vt in vertedgecounts:
    ct = vertedgecounts[vt]
    if ct != 2: cornerverts.add(vt)

# build segments
segments = []
for corner in cornerverts:
    edgecounts = vertedgecounts[corner]
    while (corner in vertconnections) and (len(vertconnections[corner]) > 0):
        newsegment = [corner]
        thisvert = corner
        while True:
            nextvert = vertconnections[thisvert].pop()
            if len(vertconnections[thisvert]) == 0:
                del(vertconnections[thisvert])
            vertconnections[nextvert].remove(thisvert)
            newsegment.append(nextvert)
            thisvert = nextvert
            if thisvert in cornerverts:
                if len(vertconnections[thisvert]) == 0:
                    del(vertconnections[thisvert])
                break
            if len(vertconnections[thisvert]) == 0:
                print("corner counting went wrong")
                raise
        segments.append(newsegment)

if VERBOSE: print(obname)
#print(edges)
if VERBOSE: print(len(edges))
#print(verts)
if VERBOSE: print(len(verts))
#print(cornerverts)
#print(vertconnections)
#print(segments)

loops = []
# all of the verts should have exactly 2 connections now
while len(vertconnections):
    loopvert, connections = vertconnections.popitem()
    vertconnections[loopvert] = connections
    newloop = [loopvert]
    thisvert = loopvert
    while True:
#        print(thisvert)
        nextvert = vertconnections[thisvert].pop()
        del(vertconnections[thisvert])
        if nextvert == loopvert:
            break
        vertconnections[nextvert].remove(thisvert)
        newloop.append(nextvert)
        thisvert = nextvert
    loops.append(newloop)

#print(vertconnections)
#print(loops)

# generate the point search list
pointstosearch = []
def grabpointdata(pid, group = 0):
    pointdata = {}
    pointdata['P'] = pid
    coords = verts[pid]
    pointdata['X'] = coords[0]
    pointdata['Y'] = coords[1]
    if group: pointdata['G'] = group
    return pointdata
for seg in segments:
    for i in (0,-1): pointstosearch.append(grabpointdata(seg[i], seg))
for loop in loops:
    for i in range(len(loop)//2): pointstosearch.append(grabpointdata(loop[i*2], loop))

# Generate the header, and initialize the machine
OutString = "(Gcode generated by Tryop Blender Exporter)\n"
# G20 is inches, G21 is mm
OutString += "G21\n"
# G90 is absolute, G91 is incremental
OutString += "G90\n"
# M05 is spindle off
# M03 is spindle on, s is the spindle speed (or laser power in this case), from 0 to 255
OutString += "M03 S0\n"
# G00 is rapid move
OutString += f"G00 X0 Y0 F{JOGSPD}\n"

def dist(p1,p2):
    return sqrt((p1["X"]-p2["X"])**2 + (p1["Y"]-p2["Y"])**2)

X = 0.
Y = 0.
curpos = {}
curpos['X'] = X
curpos['Y'] = Y

def close(p1): return dist(p1, curpos)

while len(pointstosearch):
    pointstosearch.sort(key=close)
    # if VERBOSE: print(pointstosearch)
    curpos = pointstosearch[0]
    pidx = curpos['P']
    grp = curpos['G']
    to_remove = []
    for pnt in pointstosearch:
        if pnt['G'] == grp: to_remove.append(pnt)
    for pnt in to_remove:
        pointstosearch.remove(pnt)
    # re-order the group
    if grp in loops:
        grpidx = grp.index(pidx)
        grp = grp[grpidx:] + grp[:grpidx]
        grp.append(grp[0])
    else:
        if grp[-1] == pidx:
            grp.reverse()
    if VERBOSE: print(grp)
    X = curpos['X']
    Y = curpos['Y']
    # for each segment or loop, jog to the start, turn on the laser, complete the path, and turn off again.
    OutString += f"G00 X{X:.2f} Y{Y:.2f} F{JOGSPD}\n"
    # M03 is spindle on, s is the spindle speed (or laser power in this case), from 0 to 255
    OutString += f"M03 S{LSRPOW}\n"
    for curidx in grp[1:]:
        curpos = grabpointdata(curidx)
        X = curpos['X']
        Y = curpos['Y']
        # G01 is linear motion
        OutString += f"G01 X{X:.2f} Y{Y:.2f} F{LSRSPD}\n"
    # when done, turn the laser back off
    OutString += "M03 S0\n"

# when all the engraving is done, turn the laser off and jog back to the origin
OutString += "M05\n"
OutString += f"G00 X0 Y0 F{JOGSPD}\n"


fp = Path(bpy.path.abspath(savefile))
try:
    f = open(fp, 'w')
    f.write(OutString)
    f.close()
    if VERBOSE: print('File Saved')
except:
    if VERBOSE: print('exception found while saving file')
